#include "board.h"
#include <stdio.h>
#include "rgb_led.h"
#include "rgb_led_cfg.h"
#include "can.h"
#include "can_cfg.h"
#include "uart_drv.h"
#include "uart_logger.h"
#include "uart_trace.h"
#include "interpreter.h"**
#define TICKRATE_HZ 2 /* frecventa timerului */
#define SysTickFrequence 1000 // 1000 ticks per second 1ms
// task update culoare led
int led_timer_ovf;

uint8_t data[8] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08};
uint32_t canId = 0xAABBCCDD;
uint8_t dlc = 8u;
uint16_t task_10ms = 0u;
uint16_t task_100ms = 0u;
uint16_t task_10s = 0u;
uint16_t task_500ms = 0u;
void SysTick_Handler(void)
{
	// All this function should be executed faster than 1ms
	// Parameter is the number of miliseconds
	led_timer_ovf = 1;
	task_10ms += 1u;
	task_10s += 1u;
	task_500ms += 1;
	task_100ms += 1u;

//	CAN_UpdateTimeTxData(1);
}

/**
 * @brief	Handle interrupt from 32-bit timer
 * @return	Nothing
 */
/*
 * void TIMER32_0_IRQHandler(void)
{
	if (Chip_TIMER_MatchPending(LPC_TIMER32_0, 1)) {
		Chip_TIMER_ClearMatch(LPC_TIMER32_0, 1);


	}
}
*/


int main(void)
{
	uint32_t timerFreq;
	RGB_LED_T rgb_led1;
	RGB_LED_T rgb_led2;
	RGB_LED_T rgb_led3;

	SystemCoreClockUpdate();
	Board_Init();

	/* Enable timer 1 clock */
//	Chip_TIMER_Init(LPC_TIMER32_0);
	/* Timer rate is system clock rate */
//	timerFreq = Chip_Clock_GetSystemClockRate();
	/* Timer setup for match and interrupt at TICKRATE_HZ */
/*
	Chip_TIMER_Reset(LPC_TIMER32_0);
	Chip_TIMER_MatchEnableInt(LPC_TIMER32_0, 1);
	Chip_TIMER_SetMatch(LPC_TIMER32_0, 1, (timerFreq / TICKRATE_HZ));
	Chip_TIMER_ResetOnMatchEnable(LPC_TIMER32_0, 1);
	Chip_TIMER_Enable(LPC_TIMER32_0);
*/
	/* Enable timer interrupt */
//	NVIC_ClearPendingIRQ(TIMER_32_0_IRQn);
//	NVIC_EnableIRQ(TIMER_32_0_IRQn);


	/* Enable and setup SysTick Timer at a periodic rate */
	SysTick_Config(SystemCoreClock / SysTickFrequence);
	// Initialization of CAN module
	CAN_Init();
	UartDrv_Init();
	//PIO3_0 = red led, PIO3_1 = green led, PIO3_2 = blue led


	//led 1
	//PIO3_0 = red led, PIO3_1 = green led, PIO3_2 = blue led
	RGB_LED_Init(&rgb_led1, LPC_GPIO, 3, 0, 3, 1, 3, 2, RGB_LED_ACTIVE_HIGH);
	//RGB_LED_Init(&rgb_led1, LPC_GPIO, 2, 6, 2, 3, 1, 11, RGB_LED_ACTIVE_HIGH);
	RGB_LED_SetColor(&rgb_led1, RGB_LED_OFF);

	//led 2
	//PIO0_10 = red led, PIO0_6 = green led, PIO1_8 = blue led
	//RGB_LED_Init(&rgb_led2, LPC_GPIO, 0, 10, 0, 6, 1, 8, RGB_LED_ACTIVE_HIGH);
	RGB_LED_Init(&rgb_led2, LPC_GPIO, 1, 5, 1, 8, 0, 6, RGB_LED_ACTIVE_HIGH);
	RGB_LED_SetColor(&rgb_led2, RGB_LED_OFF);

	//led 3
	//PIO1_5 = red led, PIO1_4 = green led, PIO1_3 = blue led
	//RGB_LED_Init(&rgb_led3, LPC_GPIO, 1, 5, 1, 4, 1, 3, RGB_LED_ACTIVE_HIGH);
	RGB_LED_Init(&rgb_led3, LPC_GPIO, 2, 0, 2, 1, 2, 2, RGB_LED_ACTIVE_HIGH);
	RGB_LED_SetColor(&rgb_led3, RGB_LED_OFF);


	UartMidleware_Init();
	/* RGB LED test */
	RGB_LED_COLOR_T test_col = RGB_LED_OFF;

	while (1) {
		//__WFI();
		RGB_LED_SetColor(&rgb_led1, RGB_LED_GREEN);

		if(led_timer_ovf == 1) {
			UartDrv_MainFunction();
		}

		if(task_10ms >= 10)
		{
			interpret(can_rx_database_cyclic,&buff_led1_color, &buff_led2_color, &buff_led3_color);
			RGB_LED_SetColor(&rgb_led1, buff_led1_color);
			RGB_LED_SetColor(&rgb_led2, buff_led2_color);
			RGB_LED_SetColor(&rgb_led3, buff_led3_color);
			UartMidleware_MainFucntion(task_10ms);
			task_10ms = 0u;
		}

		if(task_100ms >= 100)
		  {
		    task_100ms = 0u;
		  }

		if(task_500ms >= 500)
		{
			task_500ms = 0u;

			test_col++;
			if(test_col > RED_LED_WHITE)
				test_col = RGB_LED_OFF;
		}


		if(task_10s >= 10000)
		{
			canId = 0x100;
			data[0] = (data[0] + 1u) % 10u;
			CAN_UpdateCyclicTxMsg(canId,data);
			canId = 0x200;
			CAN_UpdateCyclicTxMsg(canId,data);
			UartLogger_AddLog((uint8_t*)"Test Log", 8u, 0);
//			UartLogger_AddStrNumLog((uint8_t*)"CAN error msg ", 13, 0xFFFF, 0u);
//			UartTrace_SendCanMsg(canId, dlc, data,UartTrace_RX);
//			UartTrace_SendCanMsg(canId, dlc, data,UartTrace_TX);
			task_10s = 0;
		}
	}

	return 0;
}
